worker_processes auto;
events { worker_connections  4096; }

http {
  # 로그 포맷(관측용)
  log_format fcfs '$msec $request $status $request_time $upstream_response_time '
                  '$request_id $remote_addr $http_x_forwarded_for';
  access_log /var/log/nginx/access.log fcfs;

  # CDN/LB 뒤라면 진짜 클라이언트 IP 복원
  real_ip_header X-Forwarded-For;
  set_real_ip_from 0.0.0.0/0;

  # Lua 패키지 경로(필요시)
  lua_package_path '/usr/local/openresty/lualib/?.lua;;';

  # 워커 초기화 훅에서 Lua 스크립트 로드(sha 캐시)
  lua_shared_dict lua_cache 1m;

  init_worker_by_lua_block {
    local dict = ngx.shared.lua_cache
    local redis = require "resty.redis"
    local r = redis:new()
    r:set_timeout(2000)
    local ok, err = r:connect(os.getenv("REDIS_HOST") or "redis", tonumber(os.getenv("REDIS_PORT")) or 6379)
    if not ok then
      ngx.log(ngx.ERR, "redis connect failed in init_worker: ", err)
      return
    end

    local script = [[
      local ukey = KEYS[1]
      local ipkey = KEYS[2]
      if redis.call("EXISTS", ukey) == 1 or redis.call("EXISTS", ipkey) == 1 then
        return 0
      end
      redis.call("SET", ukey, ARGV[1], "EX", ARGV[3])
      redis.call("SET", ipkey, ARGV[2], "EX", ARGV[3])
      return 1
    ]]
    local ok2, sha = r:script("load", script)
    if ok2 then
      dict:set("dupe_sha", sha)
    else
      ngx.log(ngx.ERR, "script load failed: ", sha)
    end
    r:set_keepalive(60000, 200)
  }

  # 간단한 레이트리밋(옵션)
  limit_req_zone $binary_remote_addr zone=fcfs:10m rate=5r/s;

  server {
    listen 80;
    # 백엔드 앱 업스트림
    upstream app_backend { server app:3000; keepalive 64; }  # 도커가 아니면 실제 주소/포트

    location = /fcfs/join {
      limit_req zone=fcfs burst=30 nodelay;

      # 중복 필터: 동일 사용자/동일 IP 재사용 불가
      access_by_lua_block {
        local redis = require "resty.redis"
        local r = redis:new()
        r:set_timeout(2000)
        local ok, err = r:connect(os.getenv("REDIS_HOST") or "redis", tonumber(os.getenv("REDIS_PORT")) or 6379)
        if not ok then
          ngx.status = 503
          ngx.say("service_unavailable")
          return ngx.exit(503)
        end

        local headers = ngx.req.get_headers()
        local user = headers["X-User-Id"]
        if not user or user == "" then
          ngx.status = 400
          ngx.say("missing_user")
          return ngx.exit(400)
        end

        local ip = ngx.var.realip_remote_addr or ngx.var.remote_addr
        local event = ngx.var.arg_event or "default"
        local ttl = tonumber(ngx.var.arg_ttl) or 900  -- 15분

        local dict = ngx.shared.lua_cache
        local sha = dict:get("dupe_sha")
        if not sha then
          -- init 실패시 대비: EVAL fallback
          local script = [[
            local ukey = KEYS[1]
            local ipkey = KEYS[2]
            if redis.call("EXISTS", ukey) == 1 or redis.call("EXISTS", ipkey) == 1 then
              return 0
            end
            redis.call("SET", ukey, ARGV[1], "EX", ARGV[3])
            redis.call("SET", ipkey, ARGV[2], "EX", ARGV[3])
            return 1
          ]]
          local res, err = r:eval(script, 2,
            "fcfs:"..event..":user:"..user,
            "fcfs:"..event..":ip:"..ip,
            user, ip, ttl)
          if not res then
            ngx.status = 503
            ngx.say("redis_error")
            return ngx.exit(503)
          end
          if res == 0 then
            ngx.status = 409
            ngx.say("duplicate")
            return ngx.exit(409)
          end
        else
          local res, err = r:evalsha(sha, 2,
            "fcfs:"..event..":user:"..user,
            "fcfs:"..event..":ip:"..ip,
            user, ip, ttl)
          if not res then
            ngx.status = 503
            ngx.say("redis_error")
            return ngx.exit(503)
          end
          if res == 0 then
            ngx.status = 409
            ngx.say("duplicate")
            return ngx.exit(409)
          end
        end

        r:set_keepalive(60000, 200)
        -- 통과 → 백엔드 프록시 계속 진행
      }

      proxy_set_header X-Request-Id $request_id;
      proxy_set_header X-Real-IP    $realip_remote_addr;
      proxy_set_header X-User-Id    $http_x_user_id;  # 클라가 보낸 헤더를 그대로 넘기려면
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      proxy_pass http://app_backend;
    }

    # 헬스체크/기본 페이지
    location = /health { return 200 "ok\n"; }
  }
}