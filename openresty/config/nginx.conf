# Base skeleton (Task 1.2)
# Further Lua access logic & reservation route will be added in later subtasks.
worker_processes auto;

error_log /var/log/nginx/error.log info;

pid /var/run/openresty.pid;

events { worker_connections  4096; }

http {
  include       mime.types;
  default_type  application/octet-stream;

  # DNS resolver for Lua scripts (Docker internal DNS)
  resolver 10.89.0.1;

  # Logging (will refine fields later)
  log_format main '$msec $remote_addr $request $status $request_time $upstream_response_time $request_id';
  access_log /var/log/nginx/access.log main;

  sendfile        on;
  keepalive_timeout  65;

  # Real IP (adjust if behind trusted LB only)
  real_ip_header X-Forwarded-For;
  set_real_ip_from 0.0.0.0/0;

  # Lua package path (mirrors Docker ENV LUA_PATH)
  lua_package_path '/etc/openresty/lua/?.lua;/usr/local/openresty/lualib/?.lua;;';

  # Shared dicts (reservation duplicate script SHA, etc.)
  lua_shared_dict lua_cache 1m;

  # Note: Preload removed from init_worker phase due to Redis API restrictions
  # Script will be loaded on first use instead

  # Basic rate limit zone (adjust values later if needed)
  limit_req_zone $binary_remote_addr zone=fcfs:10m rate=5r/s;

  upstream app_backend { server backend:5800; keepalive 64; }

  server {
    listen 80;
    server_name _;

    # Health endpoint for container orchestration
    location = /health { return 200 "ok\n"; }
  # Upstream declared above

    # Debug endpoint (non-production) to manually test duplicate filter quickly
    # curl 'http://openresty/debug/dupe?user=alice&ip=1.2.3.4'
    location = /debug/dupe {
      access_by_lua_block {
        local args = ngx.req.get_uri_args()
        local user = args.user
        local ip = args.ip or (ngx.var.realip_remote_addr or ngx.var.remote_addr)
        
        -- Debug environment variables
        local redis_host = os.getenv("REDIS_HOST") or "redis"
        local redis_port = tonumber(os.getenv("REDIS_PORT")) or 6379
        local redis_password = os.getenv("REDIS_PASSWORD")
        ngx.log(ngx.ERR, "Debug: redis_host=", redis_host, " redis_port=", redis_port, " redis_password=", redis_password or "nil")
        
        local df = require "duplicate_filter"
        local ok, reason = df.check{ user = user, ip = ip, event = args.event or 'debug', ttl = args.ttl }
        if not ok then
          ngx.status = (reason == 'duplicate') and 409 or ((reason == 'missing_user') and 400 or 503)
          ngx.say(reason)
          return ngx.exit(ngx.status)
        end
        ngx.say('allowed')
        return ngx.exit(200)
      }
    }

    # Reservation route with duplicate filtering (Task 1.5 + proxy in 1.6)
    location = /api/v1/seats/reservation {
      limit_req zone=fcfs burst=30 nodelay;
      # Access phase duplicate check
      access_by_lua_block {
        local headers = ngx.req.get_headers()
        local user = headers["X-User-Id"]
        local ip = ngx.var.realip_remote_addr or ngx.var.remote_addr
        local df = require "duplicate_filter"
        local ok, reason = df.check{ user = user, ip = ip, event = 'reservation' }
        if not ok then
          ngx.status = (reason == 'duplicate') and 409 or ((reason == 'missing_user') and 400 or 503)
          ngx.say(reason)
          return ngx.exit(ngx.status)
        end
        -- pass through to proxy
      }
      proxy_set_header X-Request-Id $request_id;
      proxy_set_header X-Real-IP    $realip_remote_addr;
      proxy_set_header X-User-Id    $http_x_user_id;
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      proxy_pass http://app_backend;
    }
  }
}
